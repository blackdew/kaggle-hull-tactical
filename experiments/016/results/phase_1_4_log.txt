/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:38: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag{lag}'] = df[col].shift(lag)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:38: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag{lag}'] = df[col].shift(lag)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:38: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag{lag}'] = df[col].shift(lag)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:38: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag{lag}'] = df[col].shift(lag)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:38: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag{lag}'] = df[col].shift(lag)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:38: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag{lag}'] = df[col].shift(lag)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:38: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag{lag}'] = df[col].shift(lag)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:38: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag{lag}'] = df[col].shift(lag)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:38: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag{lag}'] = df[col].shift(lag)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:38: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag{lag}'] = df[col].shift(lag)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:38: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag{lag}'] = df[col].shift(lag)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:38: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag{lag}'] = df[col].shift(lag)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:38: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag{lag}'] = df[col].shift(lag)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:38: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag{lag}'] = df[col].shift(lag)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:38: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag{lag}'] = df[col].shift(lag)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:38: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag{lag}'] = df[col].shift(lag)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:38: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag{lag}'] = df[col].shift(lag)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:38: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag{lag}'] = df[col].shift(lag)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:38: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag{lag}'] = df[col].shift(lag)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:38: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag{lag}'] = df[col].shift(lag)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:38: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag{lag}'] = df[col].shift(lag)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:38: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag{lag}'] = df[col].shift(lag)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:185: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_return_{period}d'] = df[col].pct_change(period)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:188: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_ema_{period}'] = df[col].ewm(span=period, adjust=False).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:185: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_return_{period}d'] = df[col].pct_change(period)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:188: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_ema_{period}'] = df[col].ewm(span=period, adjust=False).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:185: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_return_{period}d'] = df[col].pct_change(period)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:188: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_ema_{period}'] = df[col].ewm(span=period, adjust=False).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:196: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_trend'] = ema_short - ema_long
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:185: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_return_{period}d'] = df[col].pct_change(period)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:188: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_ema_{period}'] = df[col].ewm(span=period, adjust=False).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:185: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_return_{period}d'] = df[col].pct_change(period)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:188: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_ema_{period}'] = df[col].ewm(span=period, adjust=False).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:185: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_return_{period}d'] = df[col].pct_change(period)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:188: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_ema_{period}'] = df[col].ewm(span=period, adjust=False).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:196: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_trend'] = ema_short - ema_long
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:185: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_return_{period}d'] = df[col].pct_change(period)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:188: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_ema_{period}'] = df[col].ewm(span=period, adjust=False).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:185: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_return_{period}d'] = df[col].pct_change(period)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:188: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_ema_{period}'] = df[col].ewm(span=period, adjust=False).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:185: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_return_{period}d'] = df[col].pct_change(period)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:188: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_ema_{period}'] = df[col].ewm(span=period, adjust=False).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:196: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_trend'] = ema_short - ema_long
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:185: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_return_{period}d'] = df[col].pct_change(period)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:188: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_ema_{period}'] = df[col].ewm(span=period, adjust=False).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:185: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_return_{period}d'] = df[col].pct_change(period)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:188: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_ema_{period}'] = df[col].ewm(span=period, adjust=False).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:185: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_return_{period}d'] = df[col].pct_change(period)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:188: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_ema_{period}'] = df[col].ewm(span=period, adjust=False).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:196: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_trend'] = ema_short - ema_long
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:185: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_return_{period}d'] = df[col].pct_change(period)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:188: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_ema_{period}'] = df[col].ewm(span=period, adjust=False).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:185: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_return_{period}d'] = df[col].pct_change(period)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:188: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_ema_{period}'] = df[col].ewm(span=period, adjust=False).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:185: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_return_{period}d'] = df[col].pct_change(period)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:188: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_ema_{period}'] = df[col].ewm(span=period, adjust=False).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:196: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_trend'] = ema_short - ema_long
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:185: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_return_{period}d'] = df[col].pct_change(period)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:188: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_ema_{period}'] = df[col].ewm(span=period, adjust=False).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:185: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_return_{period}d'] = df[col].pct_change(period)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:188: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_ema_{period}'] = df[col].ewm(span=period, adjust=False).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:185: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_return_{period}d'] = df[col].pct_change(period)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:188: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_ema_{period}'] = df[col].ewm(span=period, adjust=False).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:196: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_trend'] = ema_short - ema_long
================================================================================
EXP-016 Phase 1.4: Baseline Comparison
================================================================================

Loading data and creating 754 features...
[INFO] Loading data and creating 754 features...
[INFO] Base features: 20
[INFO] Top 5: ['M4', 'V13', 'M1', 'S5', 'S2']
[INFO] Starting feature engineering on 20 base features
[INFO] Initial shape: (8990, 98)
[INFO] Creating lag features (1, 5, 10, 20, 40, 60)...
[INFO] After lags: (8990, 218)
[INFO] Creating rolling features (5, 10, 20, 60)...
[INFO] After rolling: (8990, 378)
[INFO] Creating cross-sectional features (rank, zscore, quantile)...
[INFO] After cross-sectional: (8990, 438)
[INFO] Creating volatility features (5, 20, 60)...
[INFO] After volatility: (8990, 618)
[INFO] Creating momentum features (5, 20, 60)...
[INFO] After momentum: (8990, 758)
[INFO] Final shape: (8990, 758)
[INFO] Added 660 features
[INFO] Total features: 754
[INFO] X shape: (8990, 754), y shape: (8990,)

Loading feature subsets...
  All features: 754
  Top 50: 50
  Top 20: 20
  Significant (p<0.05): 57

================================================================================
Experiment: All_754_features
Features: 754
================================================================================
  Fold 1/3... Sharpe: 0.707
  Fold 2/3... Sharpe: 0.725
  Fold 3/3... Sharpe: 0.734

  Average Sharpe: 0.722  0.014

================================================================================
Experiment: Top_50_features
Features: 50
================================================================================
  Fold 1/3... Sharpe: 0.587
  Fold 2/3... Sharpe: 0.976
  Fold 3/3... Sharpe: 0.965

  Average Sharpe: 0.842  0.221

================================================================================
Experiment: Top_20_features
Features: 20
================================================================================
  Fold 1/3... Sharpe: 0.732
  Fold 2/3... Sharpe: 0.994
  Fold 3/3... Sharpe: 0.896

  Average Sharpe: 0.874  0.133

================================================================================
Experiment: Significant_57_features
Features: 57
================================================================================
  Fold 1/3... Sharpe: 0.497
  Fold 2/3... Sharpe: 0.750
  Fold 3/3... Sharpe: 0.820

  Average Sharpe: 0.689  0.170

================================================================================
Summary
================================================================================
                         sharpe             mse vol_ratio n_features
                           mean     std    mean      mean      first
experiment                                                          
All_754_features         0.7221  0.0136  0.0001    1.3190        754
Significant_57_features  0.6891  0.1699  0.0001    1.3677         57
Top_20_features          0.8741  0.1326  0.0001    1.3378         20
Top_50_features          0.8425  0.2214  0.0001    1.3204         50

Comparison to Baseline (754 features):
   Top_50_features: 0.842 (+0.120, +16.7%) with 50 features
   Top_20_features: 0.874 (+0.152, +21.1%) with 20 features
   Significant_57_features: 0.689 (-0.033, -4.6%) with 57 features

Results saved to:
  - /Users/sookbunlee/work/kaggle/experiments/016/results/baseline_comparison.csv

================================================================================
Phase 1.4 Complete!
================================================================================

Key Findings:

 **57 significant features perform similarly to 754 features!**
    Null test was correct: 57/754 features are truly useful
    697 features are likely overfitting/noise

Next: Phase 1.3 (Feature Correlation) or Phase 2 (Feature Engineering)
================================================================================
