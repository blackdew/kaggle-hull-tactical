/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:38: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag{lag}'] = df[col].shift(lag)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:38: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag{lag}'] = df[col].shift(lag)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:38: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag{lag}'] = df[col].shift(lag)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:38: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag{lag}'] = df[col].shift(lag)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:38: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag{lag}'] = df[col].shift(lag)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:38: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag{lag}'] = df[col].shift(lag)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:38: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag{lag}'] = df[col].shift(lag)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:38: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag{lag}'] = df[col].shift(lag)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:38: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag{lag}'] = df[col].shift(lag)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:38: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag{lag}'] = df[col].shift(lag)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:38: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag{lag}'] = df[col].shift(lag)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:38: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag{lag}'] = df[col].shift(lag)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:38: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag{lag}'] = df[col].shift(lag)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:38: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag{lag}'] = df[col].shift(lag)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:38: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag{lag}'] = df[col].shift(lag)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:38: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag{lag}'] = df[col].shift(lag)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:38: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag{lag}'] = df[col].shift(lag)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:38: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag{lag}'] = df[col].shift(lag)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:38: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag{lag}'] = df[col].shift(lag)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:38: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag{lag}'] = df[col].shift(lag)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:38: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag{lag}'] = df[col].shift(lag)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:38: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag{lag}'] = df[col].shift(lag)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:64: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_mean_{window}'] = df[col].rolling(window).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:65: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_rolling_std_{window}'] = df[col].rolling(window).std()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:145: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_{window}'] = vol
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:148: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_norm_{window}'] = df[col] / (vol + 1e-8)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:152: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_vol_regime_{window}'] = (vol > vol_threshold).astype(int)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:185: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_return_{period}d'] = df[col].pct_change(period)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:188: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_ema_{period}'] = df[col].ewm(span=period, adjust=False).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:185: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_return_{period}d'] = df[col].pct_change(period)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:188: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_ema_{period}'] = df[col].ewm(span=period, adjust=False).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:185: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_return_{period}d'] = df[col].pct_change(period)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:188: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_ema_{period}'] = df[col].ewm(span=period, adjust=False).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:196: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_trend'] = ema_short - ema_long
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:185: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_return_{period}d'] = df[col].pct_change(period)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:188: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_ema_{period}'] = df[col].ewm(span=period, adjust=False).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:185: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_return_{period}d'] = df[col].pct_change(period)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:188: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_ema_{period}'] = df[col].ewm(span=period, adjust=False).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:185: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_return_{period}d'] = df[col].pct_change(period)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:188: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_ema_{period}'] = df[col].ewm(span=period, adjust=False).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:196: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_trend'] = ema_short - ema_long
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:185: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_return_{period}d'] = df[col].pct_change(period)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:188: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_ema_{period}'] = df[col].ewm(span=period, adjust=False).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:185: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_return_{period}d'] = df[col].pct_change(period)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:188: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_ema_{period}'] = df[col].ewm(span=period, adjust=False).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:185: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_return_{period}d'] = df[col].pct_change(period)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:188: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_ema_{period}'] = df[col].ewm(span=period, adjust=False).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:196: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_trend'] = ema_short - ema_long
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:185: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_return_{period}d'] = df[col].pct_change(period)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:188: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_ema_{period}'] = df[col].ewm(span=period, adjust=False).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:185: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_return_{period}d'] = df[col].pct_change(period)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:188: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_ema_{period}'] = df[col].ewm(span=period, adjust=False).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:185: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_return_{period}d'] = df[col].pct_change(period)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:188: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_ema_{period}'] = df[col].ewm(span=period, adjust=False).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:196: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_trend'] = ema_short - ema_long
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:185: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_return_{period}d'] = df[col].pct_change(period)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:188: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_ema_{period}'] = df[col].ewm(span=period, adjust=False).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:185: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_return_{period}d'] = df[col].pct_change(period)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:188: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_ema_{period}'] = df[col].ewm(span=period, adjust=False).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:185: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_return_{period}d'] = df[col].pct_change(period)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:188: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_ema_{period}'] = df[col].ewm(span=period, adjust=False).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:196: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_trend'] = ema_short - ema_long
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:185: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_return_{period}d'] = df[col].pct_change(period)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:188: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_ema_{period}'] = df[col].ewm(span=period, adjust=False).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:185: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_return_{period}d'] = df[col].pct_change(period)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:188: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_ema_{period}'] = df[col].ewm(span=period, adjust=False).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:185: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_return_{period}d'] = df[col].pct_change(period)
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:188: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_ema_{period}'] = df[col].ewm(span=period, adjust=False).mean()
/Users/sookbunlee/work/kaggle/experiments/007/feature_engineering.py:196: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_trend'] = ema_short - ema_long
================================================================================
EXP-016 Phase 1.2: Null Importance Test
================================================================================

This will run 100 iterations of target shuffling.
Estimated time: 30-60 minutes

Loading data and creating 754 features...
[INFO] Loading data and creating 754 features...
[INFO] Base features: 20
[INFO] Top 5: ['M4', 'V13', 'M1', 'S5', 'S2']
[INFO] Starting feature engineering on 20 base features
[INFO] Initial shape: (8990, 98)
[INFO] Creating lag features (1, 5, 10, 20, 40, 60)...
[INFO] After lags: (8990, 218)
[INFO] Creating rolling features (5, 10, 20, 60)...
[INFO] After rolling: (8990, 378)
[INFO] Creating cross-sectional features (rank, zscore, quantile)...
[INFO] After cross-sectional: (8990, 438)
[INFO] Creating volatility features (5, 20, 60)...
[INFO] After volatility: (8990, 618)
[INFO] Creating momentum features (5, 20, 60)...
[INFO] After momentum: (8990, 758)
[INFO] Final shape: (8990, 758)
[INFO] Added 660 features
[INFO] Total features: 754
[INFO] X shape: (8990, 754), y shape: (8990,)

--------------------------------------------------------------------------------
Running Null Importance Test (100 iterations)...
--------------------------------------------------------------------------------

[1.2] Running Null Importance Test (100 iterations)...
  - Iteration 10/100
  - Iteration 20/100
  - Iteration 30/100
  - Iteration 40/100
  - Iteration 50/100
  - Iteration 60/100
  - Iteration 70/100
  - Iteration 80/100
  - Iteration 90/100
  - Iteration 100/100
  - Significant features (p < 0.05): 57/754
  - Results saved to /Users/sookbunlee/work/kaggle/experiments/016/results/null_importance_test.csv

================================================================================
Phase 1.2 Complete!
================================================================================

Total features: 754
Significant features (p < 0.05): 57 (7.6%)
Removed features: 697 (92.4%)

Top 10 significant features:
  639. S5_ema_20: p=0.0000, importance=0.009916
  235. M1_rolling_mean_20: p=0.0100, importance=0.008942
  94. V9: p=0.0200, importance=0.007438
  746. M12_ema_60: p=0.0100, importance=0.007384
  718. S12_ema_60: p=0.0200, importance=0.007115
  223. V13_rolling_mean_5: p=0.0100, importance=0.006847
  241. S5_rolling_mean_10: p=0.0000, importance=0.006710
  311. E12_rolling_mean_5: p=0.0100, importance=0.006469
  487. D2_vol_norm_60: p=0.0100, importance=0.006451
  601. M12_vol_norm_20: p=0.0000, importance=0.006165

Bottom 10 (non-significant, highest p-values):
  378. V13_rank: p=1.0000, importance=0.000000
  294. E7_rolling_std_60: p=1.0000, importance=0.000000
  132. D1_lag5: p=1.0000, importance=0.000000
  729. D8_return_20d: p=1.0000, importance=0.000000
  131. D1_lag1: p=1.0000, importance=0.000000
  731. D8_return_60d: p=1.0000, importance=0.000000
  126. D2_lag5: p=1.0000, importance=0.000000
  125. D2_lag1: p=1.0000, importance=0.000000
  112. M1_lag60: p=1.0000, importance=0.000000
  735. M17_ema_5: p=1.0000, importance=0.000000

Results saved to:
  - /Users/sookbunlee/work/kaggle/experiments/016/results/null_importance_test.csv

  - /Users/sookbunlee/work/kaggle/experiments/016/results/significant_features.txt

Next: Phase 1.3 - Feature Correlation Analysis
================================================================================
